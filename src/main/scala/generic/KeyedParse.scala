package omictools
package generic


/**
 * Functions and abstractions for parsing text records and emitting key-value pairs.
 *
 * @author Vince Reuter
 */
object KeyedParse {
  import cats.data.{ NonEmptyList => NEL }
  
  /* Base type for parsing errors. */
  sealed abstract class KVParseException(msg: String) extends Exception(msg) {
    def this(err: Throwable) { this(err.getMessage) }
  }
  
  /** Error generating key for a record. */
  final case class KeyCreationException(msg: String) extends KVParseException(msg)
  object KeyCreationException {
    implicit def build: String => KeyCreationException = msg => KeyCreationException(msg)
    def apply(msg: String): KeyCreationException = new KeyCreationException(msg)
  }
  
  /** Error parsing record data. */
  final case class ValueExtractionException(msg: String) extends KVParseException(msg)
  object ValueExtractionException {
    implicit def build: String => ValueExtractionException = msg => ValueExtractionException(msg)
    def apply(msg: String): ValueExtractionException = new ValueExtractionException(msg)
  }
  
  /* Safely try to create a V from an I, wrapping the result as an Either, using exception type X for the failure case. */
  private def attempt[I, V, X](f: I => V)(i: I)(implicit buildError: String => X): Either[X, V] = {
    try { Right(f(i)) } catch { case e: Throwable => Left(buildError(e.getMessage)) }
  }

  /**
   * Map text records to key-value pair, and group according to key.
   *
   * @tparam K Type of key to generate for each record
   * @tparam V Type of value to parse from each record
   * @param records Collection of records, e.g. fields generated by splitting text lines on a delimiter
   * @param getKey How to create a "key" for a single record
   * @param extract How to parse a "value" from a single record
   * @return Either a nonempty collection of tuples of element index, exception, and data elements; 
   *    or a binding between key of type {@code K} and collection of values, each of type {@code V}
   */
  def groupTextRecords[K, V](records: Iterator[Seq[String]], getKey: Seq[String] => K, 
    extract: Seq[String] => V): Either[NEL[(Int, KVParseException, Seq[String])], Map[K, Seq[V]]] = {
    import scala.collection.mutable.{ ListBuffer, Map => MutMap }
    import cats.syntax.list._
    import KeyCreationException._
    import ValueExtractionException._
    val m = MutMap.empty[K, Seq[V]].withDefaultValue(Seq.empty[V])
    val bads = ListBuffer.empty[(Int, KVParseException, Seq[String])]
    val indexedRecords = records.zipWithIndex
    while (indexedRecords.hasNext) {
      val (r, i) = indexedRecords.next()
      val maybeKV: Either[KVParseException, (K, V)] = for {
        k <- attempt[Seq[String], K, KeyCreationException](getKey)(r)
        v <- attempt[Seq[String], V, ValueExtractionException](extract)(r)
      } yield (k, v)
      maybeKV.fold(
        err => { bads += ((i, err, r)) }, 
        kv => { val (k, v) = kv; m.put(k, m(k) :+ v) } )
    }
    Either.cond(bads.isEmpty, m.toMap, bads.toList.toNel.get)
  }

}
